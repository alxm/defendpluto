#!/usr/bin/env python3

"""
    Copyright 2017 Alex Margarit <alex@alxm.org>

    arduboy-shooter is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    arduboy-shooter is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with arduboy-shooter.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys

varIds = {
    'x': 0,
    'y': 1,
}

spriteIds = {
    'asteroid': 0,
    'enemy0': 1,
    'enemy1': 2,
    'enemy2': 3,
}

aiIds = {
    'straightdown': 0,
}

class Instruction:
    numInstructions = 0

    def __init__(self, NumTokens = 1):
        self.numTokens = NumTokens
        self.opcode = Instruction.numInstructions

        Instruction.numInstructions += 1

    def checkVar(self, Bytecode, Tokens, Index):
        token = Tokens[Index]

        if token in varIds:
            if 1 <= Index <= 4:
                Bytecode[0] |= 1 << (Index - 1)
                return varIds[token]
            else:
                return 0
        else:
            return int(token)

    def compile(self, Tokens):
        if len(Tokens) != self.numTokens:
            print('Instruction {} requires {} tokens'
                .format(Tokens[0], self.numTokens))
            sys.exit(1)

        bytecode = [self.opcode << 4]

        return self.custom_compile(Tokens, bytecode)

    def custom_compile(self, Tokens, Bytecode):
        return Bytecode

class InstructionSpawn(Instruction):
    def __init__(self):
        Instruction.__init__(self, 6)

    def custom_compile(self, Tokens, Bytecode):
        #
        # 8b    8b      8b      4b      4b      8b
        # spawn x_coord y_coord type_id ai_id   ai_args
        # spawn 64      -8      enemy0  nobrain 0
        #
        x_coord = self.checkVar(Bytecode, Tokens, 1)
        y_coord = self.checkVar(Bytecode, Tokens, 2)

        type_id = spriteIds[Tokens[3]]
        ai_id = aiIds[Tokens[4]]
        ai_args = int(Tokens[5])

        Bytecode.append(x_coord)
        Bytecode.append(y_coord)
        Bytecode.append((type_id << 4) | ai_id)
        Bytecode.append(ai_args)

        return Bytecode

class InstructionWait(Instruction):
    def __init__(self):
        Instruction.__init__(self, 2)

    def custom_compile(self, Tokens, Bytecode):
        #
        # 8b   8b
        # wait frames
        # wait 30
        #
        frames = int(Tokens[1])

        Bytecode.append(frames)

        return Bytecode

class InstructionLoop(Instruction):
    def __init__(self):
        Instruction.__init__(self, 2)

    def custom_compile(self, Tokens, Bytecode):
        #
        # 8b   8b
        # loop num_times
        # loop 10
        #
        num_times = int(Tokens[1])

        Bytecode.append(num_times)

        return Bytecode

class InstructionSet(Instruction):
    def __init__(self):
        Instruction.__init__(self, 3)

    def custom_compile(self, Tokens, Bytecode):
        #
        # 8b  8b     8b
        # set var_id value
        # set x      32
        #
        var_id = varIds[Tokens[1]]
        value = int(Tokens[2])

        Bytecode.append(var_id)
        Bytecode.append(value)

        return Bytecode

class InstructionInc(Instruction):
    def __init__(self):
        Instruction.__init__(self, 3)

    def custom_compile(self, Tokens, Bytecode):
        #
        # 8b  8b     8b
        # inc var_id value
        # inc x      16
        #
        var_id = varIds[Tokens[1]]
        value = int(Tokens[2])

        Bytecode.append(var_id)
        Bytecode.append(value)

        return Bytecode

def main(LevelFile):
    instructions = {
        'spawn': InstructionSpawn(),
        'wait': InstructionWait(),
        'waitclear': Instruction(),
        'loop': InstructionLoop(),
        'end': Instruction(),
        'over': Instruction(),
        'set': InstructionSet(),
        'inc': InstructionInc(),
    }

    bytecode = []

    with open(LevelFile, 'rU') as f:
        for line in f:
            tokens = []
            rawTokens = line.split()

            for t in rawTokens:
                if t[0] == ';':
                    break

                tokens.append(t)

            if len(tokens) == 0:
                continue

            instruction = instructions[tokens[0]]
            bytecode.append(instruction.compile(tokens))

    formatted_bytecode = ''

    for line in bytecode:
        formatted_bytecode += '\n    '

        for byte in line:
            formatted_bytecode += '0x{:0>2x},'.format((byte + 2**8) % (2**8))

    contents = """\
// Generated by levels/compile.py
PROGMEM static const uint8_t z_data_levels[] = {{{}
}};\
""".format(formatted_bytecode)

    print(contents)

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print('Usage: {} data.txt'.format(sys.argv[0]))
    else:
        main(sys.argv[1])
